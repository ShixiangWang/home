<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> 
    
    <link rel="stylesheet" href="../../../fonts/academicons-1.8.6/css/academicons.min.css"/>
    <link rel="icon" type="image/png" sizes="32x32" href="../../../logo/bodhi.png"> 
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    
    <title>控制脚本 - 王诗翔</title>
    
     
    <meta property="og:title" content="控制脚本 - Shixiang Wang | 王诗翔">
    

    
      
    

    

    
    


<link href='//cdn.bootcss.com/highlight.js/9.12.0/styles/Xcode.min.css' rel='stylesheet' type='text/css' />



    <link rel="stylesheet" href="../../../css/style.css" />
    <link rel="stylesheet" href="../../../css/mystyle.css" /> 
    <link rel="stylesheet" href="../../../css/fonts.css" />
    
<script async src="../../../js/load-typekit.js"></script>


<link rel="stylesheet" href="../../../css/custom.css" />

  </head>
  
  <body class="cn">
    <header class="masthead">
      

<h1><a href="../../../logo/ShixiangWang.png"><img src="../../../logo/ShixiangWang.png" alt="Shixiang Wang" /></a></h1>
<p align="right" style="margin-top:-50px;"><small>><i>上士闻道<br>勤而行之</i></small></p>




      <nav class="menu">
        <input id="menu-check" type="checkbox" />
        <label id="menu-label" for="menu-check" class="unselectable">
          <span class="icon close-icon">✕</span>
          <span class="icon open-icon">☰</span>
          <span class="text">Menu</span>
        </label>
        <ul>
        
        
        <li><a href="../../../">首页</a></li>
        
        <li><a href="../../../cn/about/">关于</a></li>
        
        <li><a href="../../../cn/post/">博客</a></li>
        
        <li><a href="../../../cn/read/">读书</a></li>
        
        <li><a href="../../../cn/writing">写作</a></li>
        
        <li><a href="../../../cn/research/">研究</a></li>
        
        <li><a href="../../../cn/tools/">工具</a></li>
        
        <li><a href="../../../cn/cv-cn/shixiang">简历</a></li>
        
        <li><a href="../../../logo/qrcode.jpg">公众号</a></li>
        
        <li><a href="https://www.zhihu.com/people/shixiangwang">知乎</a></li>
        
        <li><a href="../../../cn/mark">推荐阅读</a></li>
        
        <li><a href="../../../en/">English</a></li>
        
        <li><a href="../../../categories/">分类</a></li>
        
        <li><a href="../../../tags/">标签</a></li>
        
        

<li class="menu-extra"></li>



<li><a href="https://github.com/ShixiangWang/home/edit/master/content/cn/post/2017-09-04-control_shell.md" target="_blank">编辑</a></li>


<li><a href="../../../cn/index.xml" type="application/rss+xml" title="RSS feed">订阅</a></li>

<li><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="Attribution-NonCommercial-ShareAlike 4.0 International">版权</a></li>


        </ul>
      </nav>
    </header>

    <article class="main">
      <header class="title">
        

<h1>控制脚本</h1>



<h3>王诗翔 &middot 
2017-09-04</h3> 


<p style="text-align:right;">
  分类:
  
    <a href="../../../categories/shell">shell</a> &nbsp
  
  <br>
  标签:
  
    <a href="../../../tags/linux">linux</a> &nbsp
  
    <a href="../../../tags/shell">shell</a> &nbsp
  
    <a href="../../../tags/note">note</a> &nbsp
  
</p>



   
  


      </header>


<blockquote>
<p><strong>内容</strong></p>
<ul>
<li>处理信号</li>
<li>以后台模式运行脚本</li>
<li>禁止挂起</li>
<li>作业控制</li>
<li>修改脚本优先级</li>
<li>脚本执行自动化</li>
</ul>
</blockquote>
<!-- more -->
<p>除了在命令行界面世界运行脚本，还存在一些方法：<strong>向脚本发送信号、修改脚本的优先级以及在脚本运行时切换到运行模式</strong>。</p>
<p>下面逐一讲述。</p>
<h2 id="处理信号">处理信号</h2>
<p>Linux利用信号与运行在系统中的进程进行通信。我们可以通过对脚本编程，使其在收到特定信号时执行某些命令，从而实现对脚本运行的控制。</p>
<h3 id="linux信号">Linux信号</h3>
<p>Linux和应用程序可以生成超过30个信号。下面列出最常见的系统信号。</p>
<table>
<thead>
<tr>
<th align="center">信号</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="center">SIGHUP</td>
<td align="center">挂起进程</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIGINT</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SIGQUIT</td>
<td align="center">停止进程</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">SIGKILL</td>
<td align="center">无条件终止进程</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">SIGTERM</td>
<td align="center">尽可能终止进程</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">SIGSTOP</td>
<td align="center">无条件停止进程，但不是终止进程</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">SIGTSTP</td>
<td align="center">停止或暂停进程，但不是终止进程</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">SIGCONT</td>
<td align="center">继续运行停止的进程</td>
</tr>
</tbody>
</table>
<p>默认情况下，bash shell会忽略收到的任何<code>SIGQUIT</code>和<code>SIGTERM</code>信号（所以交互式shell不会被终止）。但是bash shell会处理收到的<code>SIGHUP</code>和<code>SIGINT</code>信号。</p>
<p>Shell会将这些信号传给shell脚本程序来处理。而shell脚本默认是忽略这些信号的，为了避免它，我们可以在脚本中加入识别信号的代码，并执行命令来处理信号。</p>
<h3 id="生成信号">生成信号</h3>
<p>键盘上的组合可以生成两种基本的Linux信号。它在停止或暂停失控程序时非常有用。</p>
<ol>
<li>
<p>中断程序： 使用<code>Ctrl</code>+<code>C</code>，它会发送<code>SIGINT</code>信号。</p>
<p><del>（测试没起作用，尴尬了～）</del></p>
</li>
<li>
<p>暂停进程：使用<code>Ctrl</code>+<code>Z</code>，它会发送<code>SIGTSTP</code>信号。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wsx@wsx-ubuntu:~$ sleep <span style="color:#ae81ff">1000</span>
^Z
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>+  已停止               sleep <span style="color:#ae81ff">1000</span>

</code></pre></div></li>
</ol>
<p><strong>注意</strong>：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p>
<p>方括号中的数字是shell自动为程序分配的<em>作业号</em>。shell将shell中运行的每个进程成为<em>作业</em>，并为其分配唯一的作业号。</p>
<p>退出shell时发现有停止的进程，用<code>ps</code>命令查看</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wsx@wsx-ubuntu:~$ exit
exit
有停止的任务。
wsx@wsx-ubuntu:~$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
<span style="color:#ae81ff">0</span> S  <span style="color:#ae81ff">1000</span>  <span style="color:#ae81ff">5438</span>  <span style="color:#ae81ff">5433</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -  <span style="color:#ae81ff">6153</span> wait   pts/4    00:00:00 bash
<span style="color:#ae81ff">0</span> T  <span style="color:#ae81ff">1000</span>  <span style="color:#ae81ff">5452</span>  <span style="color:#ae81ff">5438</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -  <span style="color:#ae81ff">2258</span> signal pts/4    00:00:00 sleep
<span style="color:#ae81ff">0</span> T  <span style="color:#ae81ff">1000</span>  <span style="color:#ae81ff">5456</span>  <span style="color:#ae81ff">5438</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -  <span style="color:#ae81ff">2258</span> signal pts/4    00:00:00 sleep
<span style="color:#ae81ff">4</span> R  <span style="color:#ae81ff">1000</span>  <span style="color:#ae81ff">5525</span>  <span style="color:#ae81ff">5438</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">80</span>   <span style="color:#ae81ff">0</span> -  <span style="color:#ae81ff">7665</span> -      pts/4    00:00:00 ps

</code></pre></div><p>在表示进程状态的S列中，<code>ps</code>命令将已经停止作业的状态显示为<code>T</code>。这说明命令要么被跟踪，要么被停止了。</p>
<p>如果你仍想退出shell，只需要再输入一遍<code>exit</code>。也可以用<code>kill</code>生成<code>SIGKILL</code>信号标识上<code>PID</code>杀死进程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wsx@wsx-ubuntu:~$ kill <span style="color:#ae81ff">5456</span>
wsx@wsx-ubuntu:~$ kill -9 <span style="color:#ae81ff">5456</span>
wsx@wsx-ubuntu:~$ kill -9 <span style="color:#ae81ff">5452</span>
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>-  已杀死               sleep <span style="color:#ae81ff">1000</span>
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>+  已杀死               sleep <span style="color:#ae81ff">1000</span>
</code></pre></div><h3 id="捕获信号">捕获信号</h3>
<p><code>trap</code>命令允许我们来指定shell脚本要监看并从shell中拦截的Linux信号。</p>
<p>格式为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">trap commands signals
</code></pre></div><p>下面展示一个简单的例子，看如何使用<code>trap</code>命令忽略<code>SIGINT</code>信号，并控制脚本的行为。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ cat test1.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Testing signal trapping</span>
#
trap <span style="color:#e6db74">&#34;echo &#39; Sorry! I have trapped Ctrl-C&#39;&#34;</span> SIGINT
#
echo This is a test script
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">10</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;Loop #</span>$count<span style="color:#e6db74">&#34;</span>
    sleep <span style="color:#ae81ff">1</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>
#
echo <span style="color:#e6db74">&#34;This is the end of the test script&#34;</span>
#
</code></pre></div><p>来运行测试一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ ./test1.sh
This is a test script
Loop <span style="color:#75715e">#1</span>
Loop <span style="color:#75715e">#2</span>
Loop <span style="color:#75715e">#3</span>
Loop <span style="color:#75715e">#4</span>
Loop <span style="color:#75715e">#5</span>
Loop <span style="color:#75715e">#6</span>
^C Sorry! I have trapped Ctrl-C
Loop <span style="color:#75715e">#7</span>
Loop <span style="color:#75715e">#8</span>
Loop <span style="color:#75715e">#9</span>
Loop <span style="color:#75715e">#10</span>
This is the end of the test script
</code></pre></div><h3 id="捕获信号-1">捕获信号</h3>
<p>我们也可以在shell脚本退出时进行捕获。这是<strong>在shell完成任务时执行命令的一种简便方法</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ cat test2.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Trapping the script exit</span>
#
trap <span style="color:#e6db74">&#34;echo Goodbye...&#34;</span> EXIT
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">5</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;Loop #</span>$count<span style="color:#e6db74">&#34;</span>
    sleep <span style="color:#ae81ff">1</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>
#

wangsx@SC-201708020022:~/tmp$ ./test2.sh
Loop <span style="color:#75715e">#1</span>
Loop <span style="color:#75715e">#2</span>
Loop <span style="color:#75715e">#3</span>
Loop <span style="color:#75715e">#4</span>
Loop <span style="color:#75715e">#5</span>
Goodbye...
</code></pre></div><p>当该脚本运行到退出位置，捕获就触发了，shell会执行在<code>trap</code>命令行指定的命令。就算提取退出，也能够成功捕获。</p>
<h3 id="修改或移除捕获">修改或移除捕获</h3>
<p>想在不同的位置进行不同的捕获处理，只需要重新使用带新选项的<code>trap</code>命令。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ cat test3.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Modifying a set trap</span>
#
trap <span style="color:#e6db74">&#34;echo &#39; Sorry... Ctrc-C is trapped.&#39;&#34;</span> SIGINT <span style="color:#75715e"># SIGINT是退出信号</span>
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">5</span> <span style="color:#f92672">]</span>  <span style="color:#75715e"># 当count&lt;5的时候</span>
<span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;Loop #</span>$count<span style="color:#e6db74">&#34;</span>
    sleep <span style="color:#ae81ff">1</span>    <span style="color:#75715e"># 睡1秒</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>

#
trap <span style="color:#e6db74">&#34;echo &#39; I modified the trap!&#39;&#34;</span> SIGINT
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">5</span> <span style="color:#f92672">]</span>  <span style="color:#75715e"># 当count&lt;5的时候</span>
<span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;Loop #</span>$count<span style="color:#e6db74">&#34;</span>
    sleep <span style="color:#ae81ff">1</span>    <span style="color:#75715e"># 睡1秒</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>
wangsx@SC-201708020022:~/tmp$ ./test3.sh
Loop <span style="color:#75715e">#1</span>
Loop <span style="color:#75715e">#2</span>
Loop <span style="color:#75715e">#3</span>
^C Sorry... Ctrc-C is trapped.
Loop <span style="color:#75715e">#4</span>
Loop <span style="color:#75715e">#5</span>
Loop <span style="color:#75715e">#1</span>
Loop <span style="color:#75715e">#2</span>
Loop <span style="color:#75715e">#3</span>
^C I modified the trap!
Loop <span style="color:#75715e">#4</span>
Loop <span style="color:#75715e">#5</span>
</code></pre></div><p>相当于两次不同的捕获。</p>
<p>我们也可以删除已经设置好的捕获。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ cat test3.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Modifying a set trap</span>
#
trap <span style="color:#e6db74">&#34;echo &#39; Sorry... Ctrc-C is trapped.&#39;&#34;</span> SIGINT <span style="color:#75715e"># SIGINT是退出信号  在这里设置捕获</span>
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">5</span> <span style="color:#f92672">]</span>  <span style="color:#75715e"># 当count&lt;5的时候</span>
<span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;Loop #</span>$count<span style="color:#e6db74">&#34;</span>
    sleep <span style="color:#ae81ff">1</span>    <span style="color:#75715e"># 睡1秒</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>

#
trap -- SIGINT <span style="color:#75715e"># 在这里删除捕获</span>
echo <span style="color:#e6db74">&#34;I modified the trap!&#34;</span>
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">5</span> <span style="color:#f92672">]</span>  <span style="color:#75715e"># 当count&lt;5的时候</span>
<span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;Loop #</span>$count<span style="color:#e6db74">&#34;</span>
    sleep <span style="color:#ae81ff">1</span>    <span style="color:#75715e"># 睡1秒</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>
wangsx@SC-201708020022:~/tmp$ ./test3.sh
Loop <span style="color:#75715e">#1</span>
Loop <span style="color:#75715e">#2</span>
Loop <span style="color:#75715e">#3</span>
Loop <span style="color:#75715e">#4</span>
Loop <span style="color:#75715e">#5</span>
I modified the trap!
Loop <span style="color:#75715e">#1</span>
Loop <span style="color:#75715e">#2</span>
Loop <span style="color:#75715e">#3</span>
^C
</code></pre></div><p>信号捕获被移除之后，脚本会按照原来的方式处理<code>SIGINT</code>信号。所以使用<code>Ctrl+C</code>键时，脚本运行会退出。当然，如果是在这个信号捕获移除前接受到<code>SIGINT</code>信号，那么脚本还是会捕获。（因为shell脚本运行是按步的，前面没有接收到信号捕获的移除，自然不会实现信号捕获的移除）</p>
<h2 id="以后台模式运行脚本">以后台模式运行脚本</h2>
<h3 id="后台运行脚本">后台运行脚本</h3>
<p>以后台模式运行shell脚本非常简单，只要再命令后加<code>&amp;</code>符就可以了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~$ cat test4.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Testing running in the background</span>
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">10</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">do</span>
    sleep <span style="color:#ae81ff">1</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>
wangsx@SC-201708020022:~$ ./test4.sh &amp;
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#ae81ff">69</span>
</code></pre></div><p>当添加<code>&amp;</code>符号后，命令和bash shell会分离而作为一个独立的后台进行运行。并返回作业号（方括号内）和进程ID（PID），Linux系统上运行的每一个进程都必须有一个唯一的PID。</p>
<p>当后台进程结束后，它会在终端显示出消息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>   已完成               ./test4.sh
</code></pre></div><p>需要注意的是，当后台程序运行时，它仍然会使用终端显示器显示<code>STDOUT</code>和<code>STDERR</code>消息。最好是将<code>STDOUT</code>和<code>STDERR</code>进行重定向。</p>
<h3 id="运行多个后台作业">运行多个后台作业</h3>
<p>我们可以在命令提示符中同时启动多个后台作用，然后用<code>ps</code>命令查看。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~$ ./test4.sh &amp;
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#ae81ff">117</span>
wangsx@SC-201708020022:~$ ./test5.sh &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#ae81ff">122</span>
wangsx@SC-201708020022:~$ ./test6.sh &amp;
<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span> <span style="color:#ae81ff">128</span>
wangsx@SC-201708020022:~$ ps
  PID TTY          TIME CMD
    <span style="color:#ae81ff">2</span> tty1     00:00:00 bash
  <span style="color:#ae81ff">117</span> tty1     00:00:00 test4.sh
  <span style="color:#ae81ff">122</span> tty1     00:00:00 test5.sh
  <span style="color:#ae81ff">128</span> tty1     00:00:00 test6.sh
  <span style="color:#ae81ff">135</span> tty1     00:00:00 sleep
  <span style="color:#ae81ff">136</span> tty1     00:00:00 sleep
  <span style="color:#ae81ff">137</span> tty1     00:00:00 ps
  <span style="color:#ae81ff">138</span> tty1     00:00:00 sleep
</code></pre></div><p>我们特别需要注意，如果终端退出，后台程序也会随之退出。</p>
<h2 id="在非控制台下运行脚本">在非控制台下运行脚本</h2>
<p>如果我们不想出现终端退出后台程序退出的情况，可以使用<code>nohup</code>命令来实现。</p>
<p><strong><code>nohup</code>命令运行了另外一个命令来阻断所有发送给该进程的<code>SIGHUP</code>信号。这会在退出终端会话时阻止进程退出。</strong></p>
<p>其格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~$ nohup ./test4.sh  &amp;
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#ae81ff">156</span>
wangsx@SC-201708020022:~$ nohup: 忽略输入并把输出追加到<span style="color:#e6db74">&#39;nohup.out&#39;</span>
</code></pre></div><p>由于<code>nohup</code>命令会解除终端与进程的关联，进程也就不再同<code>STDOUT</code>和<code>STDERR</code>联系在一起。它会自动将这两者重定向到名为<code>nohup.out</code>的文件中。</p>
<h2 id="作业控制">作业控制</h2>
<p>启动、停止终止以及恢复作业统称为<strong>作业控制</strong>。我们可以通过这几种方式完全控制shell环境中所有的进程的运行方式。</p>
<h3 id="查看作业">查看作业</h3>
<p>作业控制的<strong>关键命令</strong>是<code>jobs</code>命令。它允许查看shell当前正在处理的作业。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~$ cat test10.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Test job control</span>
#
echo <span style="color:#e6db74">&#34;Script Process ID: </span>$$<span style="color:#e6db74">&#34;</span>
#
count<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $count -le <span style="color:#ae81ff">10</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">do</span>
    echo <span style="color:#e6db74">&#34;Loop #</span>$count<span style="color:#e6db74">&#34;</span>
    sleep <span style="color:#ae81ff">10</span>
    count<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span> $count + <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">done</span>
#
echo <span style="color:#e6db74">&#34;End of script...&#34;</span>
#
wangsx@SC-201708020022:~$ ./test10.sh
Script Process ID: <span style="color:#ae81ff">27</span>
Loop <span style="color:#75715e">#1</span>
Loop <span style="color:#75715e">#2</span>
^Z^C <span style="color:#75715e"># 我的ctrl+z好像不起作用</span>
</code></pre></div><p>脚本用<code>$$</code>变量来显示系统分配给脚本的PID。使用Ctrl+Z组合键来停止脚本（我的在这不起作用~之前好像也是）。</p>
<p>我们使用同样的脚本，利用<code>&amp;</code>将另外一个作业作为后台进程启动。我们通过<code>jobs -l</code>命令查看作业的PID。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#ae81ff">121</span>
wangsx@SC-201708020022:~/tmp$ jobs -l
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>+   <span style="color:#ae81ff">121</span> 运行中               ./test10.sh &gt; test10.out &amp;
</code></pre></div><p>下面看<code>jobs</code>命令的一些参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>列出进程的PID以及作业号</td>
</tr>
<tr>
<td>-n</td>
<td>只列出上次shell发出的通知后改变了状态的作业</td>
</tr>
<tr>
<td>-p</td>
<td>只列出作业的PID</td>
</tr>
<tr>
<td>-r</td>
<td>只列出运行中的作业</td>
</tr>
<tr>
<td>-s</td>
<td>只列出已停止的作业</td>
</tr>
</tbody>
</table>
<p>如果仔细注意的话，我们发现作业号后面有<code>+</code>号。带加号的作业会被当成默认作业。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候只有一个带加号的作业和一个带减号的作业。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ jobs -l
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>    <span style="color:#ae81ff">132</span> 运行中               ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>-   <span style="color:#ae81ff">134</span> 运行中               ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>+   <span style="color:#ae81ff">136</span> 运行中               ./test10.sh &gt; test10.out &amp;
</code></pre></div><p>可以发现最好运行的脚本输出排在最前面。</p>
<p>我们调用了<code>kill</code>命令向默认进程发送了一个<code>SIGHUP</code>信号，终止了该作业。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#ae81ff">165</span>
wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#ae81ff">167</span>
wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span> <span style="color:#ae81ff">169</span>
wangsx@SC-201708020022:~/tmp$ jobs -l
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>    <span style="color:#ae81ff">165</span> 运行中               ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>-   <span style="color:#ae81ff">167</span> 运行中               ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>+   <span style="color:#ae81ff">169</span> 运行中               ./test10.sh &gt; test10.out &amp;
wangsx@SC-201708020022:~/tmp$ kill <span style="color:#ae81ff">169</span>
wangsx@SC-201708020022:~/tmp$ jobs -l
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>    <span style="color:#ae81ff">165</span> 运行中               ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>-   <span style="color:#ae81ff">167</span> 运行中               ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>+   <span style="color:#ae81ff">169</span> 已终止               ./test10.sh &gt; test10.out
wangsx@SC-201708020022:~/tmp$ jobs -l
<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>-   <span style="color:#ae81ff">165</span> 运行中               ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>+   <span style="color:#ae81ff">167</span> 运行中               ./test10.sh &gt; test10.out &amp;
</code></pre></div><h3 id="重启停止的作业">重启停止的作业</h3>
<p>我们可以将已经停止的作业作为后台进程或者前台进程重启。前台进程会接管当前工作的终端，所以使用时需要注意。</p>
<p>要以后台模式重启一个作业，可以用<code>bg</code>命令加上作业号（我的Window10子系统好像确实不能使用Ctrl+Z的功能，有兴趣可以自己测试一下）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ ./test10.sh
Script Process ID: <span style="color:#ae81ff">13</span>
Loop <span style="color:#75715e">#1</span>
^ZLoop <span style="color:#75715e">#2</span>
^C
wangsx@SC-201708020022:~/tmp$ bg
bash: bg: 当前: 无此任务
wangsx@SC-201708020022:~/tmp$ jobs
</code></pre></div><p>如果是默认作业，只需要使用<code>bg</code>命令。如果有多个作业，你得在<code>bg</code>命令后加上作业号。</p>
<h2 id="调整谦让度">调整谦让度</h2>
<p>在Linux中，内核负责将CPU时间分配给系统上运行的每一个进程。<strong>调度优先级</strong>是内核分配给进程的CPU时间。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。</p>
<p>调度优先级是一个整数值，从-20（最高）到+19（最低）。默认bash shell以优先级0来启动所有进程。</p>
<p>我们可以使用<code>nice</code>命令来改变shell脚本的优先级。</p>
<h3 id="nice命令">nice命令</h3>
<p>要让命令以更低的优先级运行，只要用<code>nice</code>的<code>-n</code>命令行来指定新的优先级级别。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wsx@ubuntu:~/tmp$ nice -n <span style="color:#ae81ff">10</span> ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span> <span style="color:#ae81ff">18953</span>
wsx@ubuntu:~/tmp$ ps -p <span style="color:#ae81ff">18953</span> -o pid,ppid,ni,cmd
   PID   PPID  NI CMD
 <span style="color:#ae81ff">18953</span>  <span style="color:#ae81ff">18782</span>  <span style="color:#ae81ff">10</span> /bin/bash ./test10.sh

</code></pre></div><p>如果想要提高优先级，需要使用超级用户权限。<code>nice</code>命令的<code>-n</code>选项不是必须的，只需要在破折号后面跟上优先级就行了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wsx@ubuntu:~/tmp$ nice -10 ./test10.sh &gt; test10.out &amp;
<span style="color:#f92672">[</span>6<span style="color:#f92672">]</span> <span style="color:#ae81ff">18999</span>
<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>   Done                    nice -n <span style="color:#ae81ff">10</span> ./test10.sh &gt; test10.out
wsx@ubuntu:~/tmp$ ps -p <span style="color:#ae81ff">18999</span> -o pid,ppid,ni,cmd
   PID   PPID  NI CMD
 <span style="color:#ae81ff">18999</span>  <span style="color:#ae81ff">18782</span>  <span style="color:#ae81ff">10</span> /bin/bash ./test10.sh
</code></pre></div><h3 id="renice命令">renice命令</h3>
<p>有时候我们想要改变系统上已经运行命令的优先级，这是<code>renice</code>命令可以做到的。它允许我们指定PID来改变它的优先级。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wsx@ubuntu:~/tmp$ ./test10.sh &amp;
<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span> <span style="color:#ae81ff">19086</span>
wsx@ubuntu:~$ ps -p <span style="color:#ae81ff">19086</span> -o pid,ppid,ni,cmd
   PID   PPID  NI CMD
 <span style="color:#ae81ff">19086</span>  <span style="color:#ae81ff">19070</span>   <span style="color:#ae81ff">0</span> /bin/bash ./test10.sh
wsx@ubuntu:~$ renice -n <span style="color:#ae81ff">10</span> -p <span style="color:#ae81ff">19086</span>
<span style="color:#ae81ff">19086</span> <span style="color:#f92672">(</span>process ID<span style="color:#f92672">)</span> old priority 0, new priority <span style="color:#ae81ff">10</span>
wsx@ubuntu:~$ ps -p <span style="color:#ae81ff">19086</span> -o pid,ppid,ni,cmd
   PID   PPID  NI CMD
 <span style="color:#ae81ff">19086</span>  <span style="color:#ae81ff">19070</span>  <span style="color:#ae81ff">10</span> /bin/bash ./test10.sh
</code></pre></div><h2 id="定时运行脚本">定时运行脚本</h2>
<p>Linux系统提供了多个在预定时间运行脚本的方法：<code>at</code>命令和<code>cron</code>表。</p>
<h3 id="用at命令来计划执行任务">用at命令来计划执行任务</h3>
<p><code>at</code>命令允许指定Linux系统何时运行脚本。<code>at</code>命令会将作业提交到队列中，指定shell何时运行该作业。<code>at</code>的守护进程<code>atd</code>会以后台模式运行，检查作业队列来运行作业。</p>
<p><code>atd</code>守护进程会检查系统上的一个特殊目录（通常位于<code>/var/spool/at</code>）来获取用<code>at</code>命令提交的作业。</p>
<h4 id="at命令的格式">at命令的格式</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">at <span style="color:#f92672">[</span>-f filename<span style="color:#f92672">]</span> time
</code></pre></div><p>默认，<code>at</code>命令会将<code>STDIN</code>的输入放入队列中。我们可以用<code>-f</code>参数来指定用于读取命令的文件名。<code>time</code>参数指定了Linux系统何时运行该脚本。</p>
<p><code>at</code>命令能识别多种不同的时间格式。</p>
<ul>
<li>标准的小时和分钟格式，比如10:15</li>
<li>AM/PM指示符，比如10:15 PM</li>
<li>特定可命令的时间，比如now, noon, midnight或teatime （4 PM）</li>
</ul>
<p>除了指定运行时间，还可以指定运行的日期。</p>
<ul>
<li>标准日期格式，比如MMDDYY, MM/DD/YY或DD.MM.YY</li>
<li>文本日期，比如Jul 4或Dec 25，加不加年份都可以</li>
<li>还可以指定时间增量
<ul>
<li>当前时间+25min</li>
<li>明天10:15PM</li>
<li>10:15+7天</li>
</ul>
</li>
</ul>
<p>针对不同的优先级，存在26种不同的作业队列。作业队列通常用小写字母a-z和大写字母A-Z来指代。</p>
<p>作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。可以用<code>-q</code>参数指定不同的队列字母。</p>
<h4 id="获取作业的输出">获取作业的输出</h4>
<p>Linux系统会将提交作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给用户。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 解决atd没启动的问题</span>
wangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ cat test13.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Test using at command</span>
#
echo <span style="color:#e6db74">&#34;This script ran at </span><span style="color:#66d9ef">$(</span>date +%B%d,%T<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
echo
sleep <span style="color:#ae81ff">5</span>
echo <span style="color:#e6db74">&#34;This is the script&#39;s end...&#34;</span>
#
wangsx@SC-201708020022:~/tmp$ at -f test13.sh now
warning: commands will be executed using /bin/sh
job <span style="color:#ae81ff">4</span> at Tue Sep <span style="color:#ae81ff">26</span> 12:12:00 <span style="color:#ae81ff">2017</span>
</code></pre></div><p><code>at</code>命令会显示分配给作业的作业号以及为作业安排的运行时间。<code>at</code>命令利用<code>sendmail</code>应用程序来发送邮件。如果没有安装这个工具就无法获得输出，因此在使用<code>at</code>命令时，最好在脚本中对STDOUT和STDERR进行重定向。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ cat test13b.sh
<span style="color:#75715e">#!/bin/bash</span>
<span style="color:#75715e"># Test using at command</span>
#
echo <span style="color:#e6db74">&#34;This script ran at </span><span style="color:#66d9ef">$(</span>date +%B%d,%T<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> &gt; test13b.out
echo &gt;&gt; test13b.out
sleep <span style="color:#ae81ff">5</span>
echo <span style="color:#e6db74">&#34;This is the script&#39;s end...&#34;</span> &gt;&gt; test13b.out
#
wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh now
warning: commands will be executed using /bin/sh
job <span style="color:#ae81ff">7</span> at Tue Sep <span style="color:#ae81ff">26</span> 12:16:00 <span style="color:#ae81ff">2017</span>
wangsx@SC-201708020022:~/tmp$ cat test13b.out
This script ran at 九月26,12:16:24

This is the script<span style="color:#960050;background-color:#1e0010">&#39;</span>s end...
</code></pre></div><p>这里使用了<code>-M</code>选项来屏蔽作业产生的输出信息。</p>
<h4 id="列出等待的作业">列出等待的作业</h4>
<p><code>atq</code>命令可以查看系统中有哪些作业再等待。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime
warning: commands will be executed using /bin/sh
job <span style="color:#ae81ff">11</span> at Wed Sep <span style="color:#ae81ff">27</span> 16:00:00 <span style="color:#ae81ff">2017</span>
Can<span style="color:#960050;background-color:#1e0010">&#39;</span>t open /var/run/atd.pid to signal atd. No atd running?
wangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start
<span style="color:#f92672">[</span>sudo<span style="color:#f92672">]</span> wangsx 的密码：
 * Starting deferred execution scheduler atd                                                                     <span style="color:#f92672">[</span> OK <span style="color:#f92672">]</span>
wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime
warning: commands will be executed using /bin/sh
job <span style="color:#ae81ff">12</span> at Wed Sep <span style="color:#ae81ff">27</span> 16:00:00 <span style="color:#ae81ff">2017</span>
wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh tomorrow
warning: commands will be executed using /bin/sh
job <span style="color:#ae81ff">13</span> at Wed Sep <span style="color:#ae81ff">27</span> 21:44:00 <span style="color:#ae81ff">2017</span>
wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh 13:30
warning: commands will be executed using /bin/sh
job <span style="color:#ae81ff">14</span> at Wed Sep <span style="color:#ae81ff">27</span> 13:30:00 <span style="color:#ae81ff">2017</span>
wangsx@SC-201708020022:~/tmp$ atq
<span style="color:#ae81ff">11</span>      Wed Sep <span style="color:#ae81ff">27</span> 16:00:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">12</span>      Wed Sep <span style="color:#ae81ff">27</span> 16:00:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">13</span>      Wed Sep <span style="color:#ae81ff">27</span> 21:44:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">14</span>      Wed Sep <span style="color:#ae81ff">27</span> 13:30:00 <span style="color:#ae81ff">2017</span> a wangsx
</code></pre></div><p>作业列表中显示了作业号、系统运行该作业的日期和时间以及它所在的队列位置。</p>
<h4 id="删除作业">删除作业</h4>
<p>使用<code>atrm</code>命令删除等待中的作业。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ atq
<span style="color:#ae81ff">11</span>      Wed Sep <span style="color:#ae81ff">27</span> 16:00:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">12</span>      Wed Sep <span style="color:#ae81ff">27</span> 16:00:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">13</span>      Wed Sep <span style="color:#ae81ff">27</span> 21:44:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">14</span>      Wed Sep <span style="color:#ae81ff">27</span> 13:30:00 <span style="color:#ae81ff">2017</span> a wangsx
wangsx@SC-201708020022:~/tmp$ atrm <span style="color:#ae81ff">11</span>
wangsx@SC-201708020022:~/tmp$ atq
<span style="color:#ae81ff">12</span>      Wed Sep <span style="color:#ae81ff">27</span> 16:00:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">13</span>      Wed Sep <span style="color:#ae81ff">27</span> 21:44:00 <span style="color:#ae81ff">2017</span> a wangsx
<span style="color:#ae81ff">14</span>      Wed Sep <span style="color:#ae81ff">27</span> 13:30:00 <span style="color:#ae81ff">2017</span> a wangsx
</code></pre></div><p>只能删除自己提交的作业，不能删除其他人的。</p>
<h3 id="安排需要定期执行的脚本">安排需要定期执行的脚本</h3>
<p>如果是需要定期执行的脚本，我们不需要使用<code>at</code>不断提交作业，而是可以利用Linux系统的另一个功能。</p>
<p><strong>Linux系统使用<code>cron</code>程序来安排要定期执行的作业。它会在后台运行并检查一个特殊的表（成为cron时间表），以获得已安排执行的作业。</strong></p>
<h4 id="cron时间表">cron时间表</h4>
<p><code>cron</code>时间表的格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">min hour dayofmonth month dayofweek command
</code></pre></div><p><code>cron</code>时间表允许我们用特定值、取值范围（比如1-5）或者通配符（星号）来指定条目。</p>
<p>例如，我们想在每天的10:15运行一个命令，可以使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#ae81ff">15</span> <span style="color:#ae81ff">10</span> * * * command
</code></pre></div><p>在其中三个字段使用了通配符，表明<code>cron</code>会在每个月的每天的10:15执行该命令。</p>
<p>要指定在每周一4:15PM运行命令，可以使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#ae81ff">15</span> <span style="color:#ae81ff">16</span> * * <span style="color:#ae81ff">1</span> command
</code></pre></div><p>可以用三字符的文本值mon,tue,wed,thu,fri,sat,sum或数值（0为周日，6为周六）来指定dayofweek的表项。</p>
<p><code>dayofmonth</code>可以用1-31表示。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 怎么在每个月的最后一天执行命令？</span>
<span style="color:#ae81ff">00</span> <span style="color:#ae81ff">12</span> * * * <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span><span style="color:#e6db74">`</span>date +%d -d tomorrow<span style="color:#e6db74">`</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">01</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span> ; command
</code></pre></div><p>命令列表必须指定要运行的命令或脚本的全路径名。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 例如</span>
<span style="color:#ae81ff">15</span> <span style="color:#ae81ff">10</span> * * * /home/rich/test4.sh &gt; test4out
</code></pre></div><p>注意：<code>corn</code>会用提交作业的用户账户运行脚本，所以我们在操作指定文件时必须有相应权限。</p>
<h4 id="构建cron时间表">构建cron时间表</h4>
<p>Linux提供了<code>crontab</code>命令来处理<code>cron</code>时间表。我们可以使用<code>-l</code>选项列出时间表。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ crontab -l
no crontab <span style="color:#66d9ef">for</span> wangsx
</code></pre></div><p>要添加条目，使用<code>-e</code>选项。在添加条目时，<code>crontab</code>命令会启动一个文本编辑器，使用已有的<code>cron</code>时间表作为文件内容。</p>
<h4 id="浏览cron目录">浏览cron目录</h4>
<p>如果对时间精确性要求不高，用预配置的<code>cron</code>脚本目录会更方便。有4个基本目录：hourly, daily, monthly和weekly。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wangsx@SC-201708020022:~/tmp$ ls /etc/cron.*ly
/etc/cron.daily:
apport      bsdmainutils  man-db   passwd                  upstart
apt-compat  dpkg          mdadm    popularity-contest
aptitude    logrotate     mlocate  update-notifier-common

/etc/cron.hourly:

/etc/cron.monthly:

/etc/cron.weekly:
fstrim  man-db  update-notifier-common
</code></pre></div><p>如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron每天会执行它。</p>
<h4 id="anacron程序">anacron程序</h4>
<p>如果提交的作业需要运行时系统处于关机状态，<code>cron</code>不会运行那些错过的脚本。为了解决这个问题，<code>anacron</code>程序诞生了。</p>
<p>如果<code>anacron</code>知道某个作业错过了执行时间，它会尽快运行该作业。这个功能常用于进行常规日志维护的脚本。</p>
<p><code>anacron</code>程序只会处理位于<code>cron</code>目录下的程序，比如<code>/etc/cron.monthly</code>。它使用时间戳来决定作业是否在正确的计划间隔内运行了，每个<code>cron</code>目录都有个时间戳文件，该文件位于<code>/var/spool/anacron</code>。</p>
<p><code>anacron</code>程序使用自己的时间表来检查作业目录。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">wsx@ubuntu:~$ sudo cat /var/spool/anacron/cron.monthly
<span style="color:#f92672">[</span>sudo<span style="color:#f92672">]</span> password <span style="color:#66d9ef">for</span> wsx:
<span style="color:#ae81ff">20170926</span>
wsx@ubuntu:~$ sudo cat /etc/anacrontab
<span style="color:#75715e"># /etc/anacrontab: configuration file for anacron</span>

<span style="color:#75715e"># See anacron(8) and anacrontab(5) for details.</span>

SHELL<span style="color:#f92672">=</span>/bin/sh
PATH<span style="color:#f92672">=</span>/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
HOME<span style="color:#f92672">=</span>/root
LOGNAME<span style="color:#f92672">=</span>root

<span style="color:#75715e"># These replace cron&#39;s entries</span>
<span style="color:#ae81ff">1</span>       <span style="color:#ae81ff">5</span>       cron.daily      run-parts --report /etc/cron.daily
<span style="color:#ae81ff">7</span>       <span style="color:#ae81ff">10</span>      cron.weekly     run-parts --report /etc/cron.weekly
@monthly        <span style="color:#ae81ff">15</span>      cron.monthly    run-parts --report /etc/cron.monthly

</code></pre></div><p><code>anacron</code>的时间表的基本格式和<code>cron</code>时间表略有不同：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">period delay identifier command
</code></pre></div><p><code>period</code>定义了作业多久运行一次，以天为单位。<code>anacron</code>用此条目来检查作业的时间戳文件。<code>delay</code>条目会指定系统启动后<code>anacron</code>程序需要等待多少分钟再开始运行错过的脚本。<code>command</code>条目包含了<code>run-parts</code>程序和一个<code>cron</code>脚本目录名。<code>run-parts</code>程序负责运行目录中传给它的任何脚本。</p>
<p>注意了，<code>anacron</code>不会处理执行时间需求小于一天的脚本，所以它是不会运行<code>/etc/cron.hourly</code>的脚本。</p>
<p><code>identifier</code>条目是一种特别的非空字符串，如<code>cron-weekly</code>。它用于唯一标识日志消息和错误邮件中的作业。</p>


  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="../../../cn/post/2017-09-03-linux-data-analysis-tools/">Linux数据处理命令工具</a></span>
  <span class="nav-next"><a href="../../../cn/post/2017-10-09-microarray-data-analysis/">Bioconductor分析基因芯片数据</a> &rarr;</span>
</nav>
<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/cn\/post\/2017-09-03-linux-data-analysis-tools\/';
    
  } else if (e.which == 39) {  
    
    url = '\/cn\/post\/2017-10-09-microarray-data-analysis\/';
    
  }
  if (url) window.location = url;
});
</script>





<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'eed477936be7b88a8455',
    clientSecret: '32b5dde22f3c95c4fad400a31632e34221b07e83',
    repo: 'home',
    owner: 'ShixiangWang',
    admin: ['ShixiangWang'],
    id: md5(window.location.pathname), 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>





<script async src="../../../js/fix-toc.js"></script>

<script async src="../../../js/center-img.js"></script>

<script async src="../../../js/right-quote.js"></script>

<script async src="../../../js/no-highlight.js"></script>

<script async src="../../../js/fix-footnote.js"></script>

<script async src="../../../js/math-code.js"></script>

<script async src="../../../js/external-link.js"></script>

<script async src="../../../js/alt-title.js"></script>

<script async src="../../../js/header-link.js"></script>


<script src="//yihui.org/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script async src="//yihui.org/js/center-img.js"></script>

  



<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>




  
  
  

  <div class="copyright"><a href="mailto:w_shixiang@163.com"><i class='far fa-envelope fa-1x'></i></a> · <a href="https://github.com/ShixiangWang"><i class='fab fa-github fa-1x'></i></a> · <a href="https://stackoverflow.com/users/7662327/shixiang-wang"><i class='fab fa-stack-overflow fa-1x'></i></a> · <a href="https://scholar.google.com/citations?user=FvNp0NkAAAAJ&amp;hl=zh-CN"><i class='ai ai-google-scholar ai-1x'></i></a> · <a href="https://orcid.org/0000-0001-9855-7357"><i class='ai ai-orcid ai-1x'></i></a> · <a href="https://www.researchgate.net/profile/Wang_Shixiang4"><i class='ai ai-researchgate ai-1x'></i></a> <br> 本站由 <a href="https://gohugo.io">Hugo</a> 和 <a href="https://bookdown.org/yihui/blogdown/">Blogdown</a> 强力驱动 © <a href="../../../">王诗翔</a> 2017 - 2020 </div>
  
  

  <script type="text/javascript" src="//rf.revolvermaps.com/0/0/6.js?i=56h9es09xn7&amp;m=6&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=1" async="async"></script>
  </footer>
  </article>
  
  </body>
</html>

